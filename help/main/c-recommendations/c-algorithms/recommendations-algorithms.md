---
keywords: 권장 사항 알고리즘;모델 교육;모델 제공;컨텐츠 전달;항목 기반;사용자 기반;인기도 기반;장바구니 기반;사용자 지정 기준
description: 에 사용되는 알고리즘에 대해 알아봅니다. [!DNL Target Recommendations]모델 교육 및 모델 제공 등
title: Target의 Recommendations 알고리즘 이면의 과학에 대해 알려면 어떻게 해야 합니까?
feature: Recommendations
mini-toc-levels: 2
exl-id: c156952b-8eda-491d-a68e-d3d09846f640
source-git-commit: 719eb95049dad3bee5925dff794871cd65969f79
workflow-type: tm+mt
source-wordcount: '2864'
ht-degree: 0%

---

# ![PREMIUM](/help/main/assets/premium.png) Target의 추천 알고리즘 이면의 과학

에 사용되는 알고리즘에 대한 심층적인 설명 [!DNL Adobe Target Recommendations]모델 교육의 논리 및 수학 세부 정보와 모델 제공 프로세스를 포함합니다.

모델 트레이닝은 [!DNL Adobe Target] 학습 알고리즘. 모델 제공은 [!DNL Target] 에서는 사이트 방문자(콘텐츠 전달이라고도 함)에게 권장 사항을 제공합니다.

[!DNL Target] 에는 다음과 같은 광범위한 유형의 알고리즘이 포함되어 있습니다. [!DNL Recommendations]:

* **항목 기반 알고리즘**: &quot;이 항목을 보고/구매한 다른 사람도 이 항목을 보고/구입한 사람&quot; 논리를 따르는 알고리즘을 포함합니다. 이러한 알고리즘은 기본 용어 항목 협업 필터링과 함께 그룹화됩니다 [!UICONTROL 비슷한 속성을 갖는 항목] 알고리즘.

* **사용자 기반 알고리즘**: 다음을 포함합니다 [!UICONTROL 최근에 본 항목] 및 [!UICONTROL 권장 사항] 알고리즘.

* **인기도 기반 알고리즘**: 웹 사이트에서 가장 많이 본 항목 또는 가장 많이 구매한 항목을 반환하거나, 카테고리 또는 항목 속성별로 가장 많이 본 항목 또는 가장 많이 구매한 항목을 반환하는 알고리즘을 포함합니다.

* **장바구니 기반 알고리즘**: &quot;이러한 항목을 보고, 구매하고, 해당 항목도 보거나, 구입한 사람&quot;이라는 논리를 사용하여 다중 항목 기반 권장 사항을 포함하십시오.

* **사용자 지정 기준**: 에 업로드된 사용자 지정 파일을 기반으로 한 권장 사항 포함 [!DNL Target].

>[!NOTE]
>
>각 알고리즘 유형 및 개별 알고리즘에 대한 자세한 내용은 [권장 사항 키를 기반으로 권장 사항 만들기](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md).

위에 나열된 알고리즘 중 다수는 하나 또는 여러 개의 키가 있는지 여부에 따라 예측됩니다. 이러한 키는 콘텐츠 전달 시(권장 사항이 수행될 때) 유사한 항목을 검색하는 데 사용됩니다. 고객이 지정한 키에는 사용자가 보고 있는 현재 항목, 마지막으로 본 항목 또는 구매한 항목, 가장 많이 본 항목, 현재 카테고리 또는 해당 방문자의 즐겨찾기 카테고리가 포함될 수 있습니다. 장바구니 기반 또는 사용자 기반 권장 사항과 같은 다른 알고리즘에서는 암시적 키(고객이 구성할 수 없는 키)를 사용합니다. 자세한 내용은 *권장 사항 키*, in [권장 사항 키를 기반으로 권장 사항 만들기](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md#keys). 그러나 이러한 키는 모델 제공 시간(컨텐츠 전달)에서만 관련되어 있습니다. 이러한 키는 &quot;오프라인&quot; 또는 모델 교육 시간 논리에 영향을 주지 않습니다.

다음 섹션은 위에서 설명한 알고리즘 유형과 약간 다른 방식으로 알고리즘을 그룹화합니다. 다음 그룹화는 모델 교육 로직의 유사성을 기반으로 합니다.

## 품목-품목 협업 필터링

알고리즘 에는 다음이 포함됩니다.

* [!UICONTROL 이 항목을 보고 다른 항목도 본 사람]
* [!UICONTROL 이 항목을 보고 다른 항목을 구입한 사람]
* [!UICONTROL 이 항목을 구입하고 다른 항목도 구입한 사람]

항목-품목 협업 필터링 권장 사항 알고리즘은 많은 사용자의 행동 패턴을 사용하여(따라서 공동 작업) 주어진 항목에 대한 유용한 권장 사항을 제공해야 한다는 아이디어를 기반으로 합니다(예: 추천할 가능한 항목의 카탈로그를 필터링). 비록 다음과 같은 일반적인 알고리즘에 속하는 다양한 알고리즘들이 있지만 [공동 작업 필터링](https://en.wikipedia.org/wiki/Collaborative_filtering), 이러한 알고리즘은 일반적으로 행동 데이터 소스를 입력으로 사용합니다. in [!DNL Target Recommendations]이러한 입력은 사용자의 항목 고유 보기 및 구매입니다.

이 항목을 보고/구매한 사람이 이러한 항목을 보고/구매한 경우&quot; 알고리즘의 경우 목표는 모든 항목 쌍 간에 유사성 s(A,B)를 계산하는 것입니다. 주어진 항목 A에 대해 상위 권장 사항은 유사성(A,B)별로 정렬됩니다.

이러한 유사성의 한 가지 예는 항목 간의 공동 발생입니다. 두 항목을 모두 구입한 사용자 수의 단순 수입니다. 직관적이긴 하지만, 이러한 지표는 인기 있는 항목을 추천하는 것에 치우쳐 있다는 점에서 순진합니다. 예를 들어, 식료품 소매점에서 대부분의 사람들이 빵을 구매한다면, 빵은 모든 품목과 높은 연관성을 가질 것이지만, 그것이 반드시 좋은 추천은 아니다. [!DNL Target] 대신 LLR(로그 가능성 비율)이라고 하는 보다 정교한 유사성 지표를 사용합니다. A와 B의 두 개 항목이 동시에 발생할 가능성이 두 항목이 공존하지 않을 확률과 매우 다를 때 이 양은 큽니다. 콘크리트의 경우 [!UICONTROL 이 항목을 보고 다른 항목을 구입한 사람] 알고리즘에 대해 설명합니다. LLR과 유사성은 B를 구입한 확률이 매우 높습니다 *not* 누가 A를 보았는지 여부에 상관없이.

예를 들어

![조회/구매 알고리즘에 대한 공식](assets/formula.png)

그런 다음 품목 B를 품목 A와 함께 권장하지 않아야 합니다. 이 로그 가능성 비율 유사성 계산에 대한 전체 세부 정보가 제공됩니다 [이 PDF](/help/main/c-recommendations/c-algorithms/assets/log-likelihood-ratios-recommendation-algorithms.pdf).

실제 알고리즘 구현의 논리 플로우는 다음 도식 다이어그램에 표시됩니다.

![조회/구입한 알고리즘의 도식 다이어그램](assets/diagram1.png)

이러한 단계의 세부 사항은 다음과 같습니다.

* **입력 데이터**: 행동 데이터, 다음을 수행할 때 수집된 방문자 보기 및 구매 형태 [Target 구현](https://developer.adobe.com/target/implement/recommendations/){target=_blank} 또는 [Adobe Analytics](/help/main/c-recommendations/c-algorithms/use-adobe-analytics-with-recommendations.md){target=_blank}.

* **모델 교육**:

   * **데이터 정리 및 샘플링**: N일 전환 확인을 사용하는 알고리즘의 경우 동작 데이터는 먼저 해당 N일 데이터만 포함하도록 필터링됩니다. 그런 다음 권장 사항을 사용하지 않아야 하는 모든 항목을 제거하는 데 컬렉션 규칙 및 글로벌 제외가 적용됩니다. 마지막으로 1,000개 이상의 항목과 상호 작용한 방문자의 사용 데이터는 1,000개 항목만 갖습니다.
   * **항목 유사성 계산**: 다음은 핵심 계산 단계입니다. 모든 후보 항목 쌍 간의 로그 우도 비율 유사도와 이 유사성 점수로 항목의 순위 쌍을 계산합니다.
   * **오프라인 필터링**: 마지막으로 적용 가능한 모든 다이내믹 필터(예: 다이내믹 카테고리 제외)가 적용됩니다. 이 단계 후에는 미리 계산된 권장 사항을 전체적으로 캐시하여 제공할 수 있습니다.

* **모델 제공**: Recommendations 콘텐츠은 [!DNL Target]s [글로벌 &quot;에지&quot; 네트워크](/help/main/c-intro/how-target-works.md#concept_0AE2ED8E9DE64288A8B30FCBF1040934). mbox 요청이에 대한 경우 [!DNL Target] 권장 사항 컨텐츠는 적절한 페이지에 대한 요청인 페이지에 전달되어야 한다고 결정됩니다 [항목 키](/help/main/c-recommendations/c-algorithms/base-the-recommendation-on-a-recommendation-key.md#keys) 의 경우 권장 사항 알고리즘은 요청에서 구문 분석되거나 사용자 프로필에서 조회된 다음 이전 단계에서 계산된 권장 사항을 검색하는 데 사용됩니다. 현재는 적절한 시간 전에 추가 동적 필터가 적용됩니다 [디자인](/help/main/c-recommendations/c-design-overview/create-design.md) 가 렌더링됩니다.

## 콘텐츠 유사성

포함된 알고리즘:

* [!UICONTROL 비슷한 속성을 갖는 항목]

이 유형의 알고리즘에서는 이름 및 텍스트 설명이 의미상 유사한 경우 두 개의 항목이 관련된 것으로 간주됩니다. 행동 데이터 소스를 사용해야 하는 대부분의 권장 사항 알고리즘과 달리 콘텐츠 유사성 알고리즘은 제품 카탈로그의 메타데이터를 사용하여 항목 간의 유사성을 도출합니다. [!DNL Target] 따라서 동작 데이터가 수집되지 않은 경우(예: 의 시작 시) 소위 &quot;콜드 시작&quot; 시나리오에서 권장 사항을 제공할 수 있습니다 [!DNL Target] 활동).

모델이 의 여러 측면을 제공하고 [!DNL Target]의 콘텐츠 유사성 알고리즘은 다른 항목 기반 알고리즘과 동일하며 모델 교육 단계는 크게 다르며 다음 다이어그램에 설명된 대로 일련의 자연어 처리 및 사전 처리 단계를 포함합니다. 유사성 계산의 핵심은 카탈로그의 각 항목을 나타내는 수정된 tf-idf 벡터의 코사인 유사성을 사용하는 것입니다.

![콘텐츠 유사성 프로세스의 흐름을 보여주는 다이어그램](assets/diagram2.png)

이러한 단계의 세부 사항은 다음과 같습니다.

* **입력 데이터**: 앞에서 설명한 바와 같이, 이 알고리즘은 순전히 카탈로그 데이터(다음 항목에 수집됨)를 기반으로 합니다 [!DNL Target] 사용 [카탈로그 피드, 엔티티 API 또는 페이지 내 업데이트](https://developer.adobe.com/target/implement/recommendations/){target=_blank}.

* **모델 교육**:

   * **속성 추출**: 일반 정적 필터, 카탈로그 규칙 및 글로벌 제외를 적용한 후 이 알고리즘은 엔티티 스키마에서 관련 텍스트 필드를 추출합니다. [!DNL Target] 엔티티 속성에서 이름, 메시지 및 카테고리 필드를 자동으로 사용하고 사용자 지정에서 문자열 필드를 추출하려고 합니다 [엔티티 속성](/help/main/c-recommendations/c-products/entity-attributes.md). 이 프로세스는 해당 필드의 값의 대부분을 숫자, 날짜 또는 부울로 구문 분석할 수 없도록 하여 수행됩니다.
   * **기식 제거**: 보다 정확한 텍스트 유사성 일치의 경우 항목의 의미를 크게 변경하지 않는 매우 일반적인 &quot;중지&quot; 단어(예: &quot;was&quot;, &quot;is&quot;, &quot;and&quot; 등)를 제거하는 것이 신중합니다. 마찬가지로, 형태소(steaming)는 루트 단어에 서로 다른 접미사를 가진 단어를 줄이는 과정을 의미하며, 동일한 의미(예: &quot;connect&quot;, &quot;connecting&quot;, &quot;connection&quot;)를 가진 단어들은 모두 동일한 루트 단어를 가집니다. &quot;connect&quot;). [!DNL Target] Snowball Stemmer를 사용합니다. [!DNL Target] 자동 언어 검색을 먼저 수행하고 최대 50개 언어 및 18개 언어에 대한 어법 제거를 중지할 수 있습니다.
   * **n그램 작성**: 이전 단계 후에는 각 단어가 토큰으로 처리됩니다. 토큰의 연속 시퀀스를 단일 토큰에 결합하는 프로세스를 n-gram 생성이라고 합니다. [!DNL Target]의 알고리즘에서는 최대 2그램을 고려합니다.
   * **tf-idf 계산**: 다음 단계에는 항목 설명에 토큰의 상대적 중요도를 반영하도록 tf-idf 벡터를 만드는 작업이 포함됩니다. 항목 i의 각 토큰/용어 t에 대해 |D| 항목에서는 단어 빈도 TF(t, i)가 먼저 계산됩니다(항목 i에 용어가 표시되는 횟수). 문서 빈도 DF(t, D)가 먼저 계산됩니다. 기본적으로 토큰이 있는 항목의 수입니다. 그러면 tf-idf 측정값이

      ![tf-idf 측정을 보여주는 공식](assets/formula2.png)

      [!DNL Target] apache Spark 사용 *tf-idf* 후드 아래에 있는 기능 구현 은 각 토큰을 218 토큰 공간에 고정합니다. 이 단계에서 고객이 지정한 특성 증폭 및 매장은 또한 [기준](/help/main/c-recommendations/c-algorithms/create-new-algorithm.md#similarity).

   * **항목 유사성 계산**: 최종 품목 유사성 계산은 대략적인 코사인 유사성을 사용하여 수행됩니다. 두 가지 품목, *A* 및 *B*&#x200B;이고 벡터 tA와 tB를 사용하는 경우 코사인 유사성은 다음과 같이 정의됩니다.

      ![항목 유사성 계산을 보여주는 공식](assets/formula3.png)

      모든 N x N 항목 간의 컴퓨팅 유사성이 크게 복잡하지 않게 하려면 *tf-idf* 벡터는 가장 큰 500개의 항목만 포함하도록 잘리며 이렇게 잘린 벡터 표현을 사용하여 항목 간의 코사인 유사성을 계산합니다. 이 접근 방식은 지역 구분 해싱과 같은 다른 가까운 ANN(근사 근사 이웃) 기술에 비해 스파스 벡터 유사성 계산에 더 강력합니다.

   * **모델 제공**: 이 프로세스는 이전 섹션에서 설명하는 항목 간 협업 필터링 기법과 동일합니다.

## 다중 키 권장 사항

알고리즘 에는 다음이 포함됩니다.

* 장바구니 기반 권장 사항
* [!UICONTROL 권장 사항]

에 대한 가장 최근 추가 사항 [!DNL Target] 추천 알고리즘 세트는 [!UICONTROL 권장 사항] 및 일련의 장바구니 기반 권장 사항 알고리즘을 만듭니다. 두 유형의 알고리즘 모두 공동 작업 필터링 기술을 사용하여 개별 항목 기반 권장 사항을 만듭니다. 그런 다음 사용자 검색 내역에서 서버 시간에 여러 항목을 찾습니다. [!UICONTROL 권장 사항]) 또는 사용자의 현재 장바구니(장바구니 기반 권장 사항용)는 이러한 항목 기반 권장 사항을 검색하는 데 사용됩니다. 그러면 최종 권장 사항 목록을 만드는 데 병합됩니다. 개인화된 권장 사항 알고리즘의 여러 가지 유형이 있습니다. 다중 키 알고리즘 선택은 방문자가 탐색 기록을 가지고 있고 권장 사항이 최신 방문자 행동에 응답하도록 업데이트될 수 있으면 즉시 권장 사항을 사용할 수 있음을 의미합니다.

이러한 알고리즘은 항목 기반 권장 사항 섹션에 설명된 기본 협업 필터링 기술을 기반으로 구축되지만 하이퍼매개 변수 튜닝을 통합하여 항목 간의 최적 유사성 지표를 결정합니다. 이 알고리즘에서는 각 사용자에 대해 행동 데이터의 시간 분할을 수행하고 나중에 사용자가 보거나 구매하는 항목을 예측하려고 시도하는 동안 이전 데이터에 대한 권장 사항 모델을 교육합니다. 최적의 결과를 만들어내는 유사성 지표 [평균 평균 정밀도](https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision) 이 선택됩니다.

모델 교육 및 점수 책정 단계의 논리가 다음 다이어그램에 나와 있습니다.

![모델 교육 및 점수 책정 단계의 논리를 보여주는 다이어그램](assets/diagram3.png)

이러한 단계의 세부 사항은 다음과 같습니다.

* **입력 데이터**: 이는 항목 간 CF(Collaborative Filtering) 메서드와 동일합니다. [!UICONTROL 두 가지 모두 권장되는 옵션] 및 장바구니 기반 알고리즘에서는 다음과 같은 경우 수집된 사용자의 보기 및 구매 형태로 행동 데이터를 사용합니다 [Target 구현](https://developer.adobe.com/target/implement/recommendations/){target=_blank} 또는 [Adobe Analytics](/help/main/c-recommendations/c-algorithms/use-adobe-analytics-with-recommendations.md){target=_blank}.

* **모델 교육**:

   * **데이터 정리 및 샘플링**: 이는 공동 작업 필터링 방법의 경우, 전환 확인 기간을 적용하여 동작 데이터를 적절한 날짜 범위로 필터링하고, 카탈로그 규칙 및 글로벌 제외의 적용을 받습니다. 1,000개 이상의 항목과 상호 작용한 방문자는 가장 최근 1,000개의 사용 용도를 고려하고 있습니다.
   * **열차 시험 분할**: 각 사용자에 대한 사용 시간을 시간 순서대로 분할하고, 사용량의 처음 80%를 교육 데이터에 할당하고 나머지 20%는 테스트 데이터에 할당됩니다.
   * **품목 유사성 모델 교육**: 코어 항목 유사성 계산은 [!UICONTROL 권장 사항] 및 후보 항목 벡터가 구성되는 방식으로 장바구니 기반 알고리즘을 만듭니다. 대상 [!UICONTROL 권장 사항]를 지정하는 항목 벡터에는 차원 NUsers가 있습니다. 여기서 각 항목은 해당 항목의 사용자에 대한 암시적 등급 합계를 나타냅니다. 항목 구매에는 항목의 보기 중 2배의 가중치가 제공됩니다. 장바구니 기반 권장 사항의 경우 항목 벡터에는 이진 항목이 있습니다. 세션 내 동작만 간주하는 경우 모든 세션에 대한 새 항목이 있습니다. 그렇지 않으면 모든 방문자에 대해 이 항목 벡터에 항목이 있습니다.

   교육 단계에서는 다음과 같은 몇 가지 유형의 벡터 유사성을 계산합니다. LLR 유사성 ([여기에서 설명합니다.](/help/main/c-recommendations/c-algorithms/assets/log-likelihood-ratios-recommendation-algorithms.pdf)), 코사인 유사성(이전에 정의됨) 및 표준화된 L2 유사성(다음과 같이 정의됨)

   ![교육 계산을 보여주는 공식](assets/formula4.png)

   * **항목 유사성 모델 평가**: 모델 평가는 이전 단계에서 생성된 추천을 받아 테스트 데이터 세트에 대해 예측하여 수행됩니다. 온라인 점수 책정 단계는 테스트 데이터 세트에 있는 각 사용자의 항목 사용을 시간순으로 정렬한 다음, 후속 보기 및 구매를 예측하기 위해 순서가 지정된 항목 하위 집합에 대해 100개의 권장 사항을 만들어 모방합니다. 정보 검색 지표, [평균 평균 정밀도](https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision)는 이러한 권장 사항의 품질을 평가하는 데 사용됩니다. 이 지표는 권장 사항 순서를 고려하며 등급 시스템의 중요한 자산인 권장 사항 목록에서 상위 관련 항목을 선호합니다.
   * **모델 선택**: 오프라인 평가 후 평균 정밀도가 가장 높은 모델을 선택하고 이에 대해 계산된 모든 개별 항목 권장 사항을 선택합니다.
   * **오프라인 필터링**: 모델 교육의 마지막 단계는 적용 가능한 동적 필터의 적용입니다. 이 단계 후에는 미리 계산된 권장 사항을 전체적으로 캐시하여 제공할 수 있습니다.


* **모델 제공**: 권장 사항을 제공하는 이전 알고리즘과 달리 에서는 검색을 위해 단일 키를 지정하고 비즈니스 규칙을 적용할 경우 [!UICONTROL 권장 사항] 및 장바구니 기반 알고리즘에서는 보다 복잡한 런타임 프로세스를 사용합니다.

   * **다중 키 검색 및 병합**: 장바구니 기반 권장 사항의 경우, 장바구니에서 전달되는 최대 10개의 항목이 각각 검색 및 권장 사항에 대한 키로 간주됩니다. 대상 [!UICONTROL 권장 사항]에서는 마지막으로 본 5개의 고유 항목 및 마지막으로 구매한 5개의 고유 구매 항목이 검색 키로 간주되며, 구매 항목에서 발생하는 권장 사항보다 두 배 더 많은 권장 사항이 고려됩니다. 권장 사항을 병합할 때 항목이 여러 개별 권장 사항 목록에 표시되면 가중 유사성 점수가 추가됩니다. 이 단계의 권장 사항 최종 목록은 내림차순으로 정렬된 가중치가 적용된 권장 사항 병합 목록입니다.
   * **필터링**: 그런 다음 이전에 본 항목 및/또는 구매한 항목 제거와 같은 필터링 규칙과 기타 동적 비즈니스 규칙이 적용됩니다.

이러한 프로세스는 방문자가 항목 A를 보고 항목 B를 구매한 다음 이미지에 표시됩니다. 개별 권장 사항은 각 항목 레이블 아래에 표시된 오프라인 유사성 점수로 검색됩니다. 검색 후 권장 사항은 합해진 가중치 유사성 점수와 병합됩니다. 마지막으로, 고객이 이전에 보고 구매한 항목을 필터링해야 한다고 지정한 시나리오에서 필터링 단계는 권장 사항 목록에서 A 및 B 항목을 제거합니다.

![다중 키 알고리즘 처리를 보여주는 다이어그램](assets/diagram4.png)

## 인기도 기반

알고리즘 에는 다음이 포함됩니다.

* [!UICONTROL 사이트에서 가장 많이 본 항목]
* [!UICONTROL 카테고리별로 가장 많이 본 항목]
* [!UICONTROL 품목 속성별로 가장 많이 본 항목 속성]
* [!UICONTROL 사이트 간 최상위 판매자]
* [!UICONTROL 카테고리별 최상위 판매자]
* [!UICONTROL 항목별 최상위 판매자 속성]

[!DNL Target] 에서는 가장 많이 본 항목과 웹 사이트 간 상위 판매 항목에 대한 인기도 기반 알고리즘을 제공하거나 항목 속성 또는 카테고리로 분류합니다. 인기도 기반 알고리즘은 지정된 기간 동안 해당 항목을 보거나 구매한 세션 수에 따라 항목의 등급을 매깁니다.

이 모든 알고리즘에서는 항목을 보고 구매한 총 세션 수가 시간별 및 일별 해상도로 기록되는 집계된 동작 데이터를 결합합니다. 그런 다음 개별 알고리즘에서 고객이 구성한 전환 확인 기간에 대해 가장 많이 본 항목 또는 가장 많이 구매한 항목을 찾습니다.

개별 알고리즘의 미묘한 뉘앙스는 다음과 같습니다.

* [!UICONTROL 사이트에서 가장 많이 본 항목] 및 [!UICONTROL 사이트 간 최상위 판매자] 항목을 각 항목을 보거나 구매한 총 세션 수에 따라 등급을 매깁니다. 출력은 권장 항목의 단일(키가 없는) 목록입니다.
* 가장 많이 본/카테고리/품목 속성별 최상위 판매자는 항목이 이러한 항목을 보거나 구매했지만 항목 카테고리 또는 특정 항목 속성별로 그룹화된 세션의 총계별로 정렬되는 권장 사항입니다. 이 출력은 추천 항목의 목록이며, 카테고리 값 또는 항목 속성 값으로 입력됩니다.

## 최근에 본 항목

최근에 본 추천 알고리즘을 사용하면 추천 세션 내 개인화를 사용할 수 있습니다. 이 알고리즘에는 오프라인 &quot;모델 교육&quot;이 필요하지 않습니다. 대신, [!DNL Target] 는 고유한 [방문자 프로필](/help/main/c-target/c-visitor-profile/visitor-profile.md) 를 사용 중인지 여부에 따라 지정된 세션에서 열람된 항목의 실행 목록을 유지하고 권장 사항 활동에서 이러한 항목을 표시할 수 있습니다. 이렇게 하면 권장 사항 및 다음 페이지 개인화에 대한 실시간 업데이트가 가능합니다.

## 사용자 지정 기준

사용자 지정 기준을 통해 고객이 [고유한 권장 사항 업로드 [!DNL Target]](/help/main/c-recommendations/c-algorithms/recommendations-csv.md)중요한 유연성을 제공하고 &quot;고유한 모델 제공&quot; 기능을 허용합니다. 사용자 지정 기준은 [!UICONTROL 항목 기반] 권장 사항이지만, 온라인 컨텐츠 전달 단계 동안 항목 기반 권장 사항 알고리즘과 유사하게 동작합니다. 이 경우 권장 사항 및 비즈니스 규칙/필터를 검색하는 데 단일 키가 사용됩니다.
